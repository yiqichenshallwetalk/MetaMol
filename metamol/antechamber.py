import os
from distutils.spawn import find_executable
from subprocess import PIPE, Popen

from metamol.utils.help_functions import tempdir, cd
from metamol.exceptions import MetaError

__all__ = ["ante_charges", "_antechamber_error", "_read_amber_charges"]

ANTECHAMBER = find_executable("antechamber")

def ante_charges(mol, charge_method='bcc', net_charge=0.0, multiplicity=1, charge_tol=0.005, scfconv=1.0e-10, ndiis_attempts=0):
    """Calculates partial charges by calling antechamber

    Parameters
    ----------
    mol : meta.Molecule
        molecule to perform charge calculation on
    charge_methd : str, optional, default=bcc
        Partial charges calculation Method. Options include
        'bcc', 'gas' and 'mul'
    net_charge : float, optional, default=0.0
        Net charge of the molecule
    multiplicity : int, optional, default=1
        Spin multiplicity, 2S + 1
    charge_tol: float, optional, default=0.005
        Tolerence of charge calculations
    scfconv: float, optional, default=1.0e-10
        Convergence criteria for the SCF calculation
    ndiis_attempts: int, optional, default=0
        Number of the attempted DIIS iterations

    Returns
    -------
    mol : meta.Molecule
        The molecule with charges applied
    charge_dict: dict
        The dictionary contianing charge information
    """    

    if not ANTECHAMBER:
        msg = (
            "Antechamber is not found. Please make sure that ambertools"
            "is installed. You can install it by `conda install -c conda-forge ambertools`"
        )
        raise IOError(msg)

    charge_methods = ['bcc', 'gas', 'mul']
    if charge_method not in charge_methods:
        raise MetaError(
            "Charge method not supported. "
            "Please choose one from {0}".format(charge_methods))

    work_dir = os.getcwd()
    with tempdir() as temp_dir:
        with cd(temp_dir):
            mol.save('temp_in.pdb')
            antecharge = (
                "antechamber -i temp_in.pdb -fi pdb "
                "-o temp_out.mol2 -fo mol2 -c {0} "
                "-nc {1} -m {2} -s 2 "
                "-ek \"qm_theory=\'AM1\', grms_tol={3}, scfconv={4}, ndiis_attempts={5},\" ".format(
                    charge_method, net_charge, multiplicity, charge_tol, scfconv, ndiis_attempts)
                )
            
            proc = Popen(antecharge, stdout=PIPE, stderr=PIPE, universal_newlines=True, shell=True)
            out, err = proc.communicate()

            if "Fatal Error" in err or proc.returncode != 0:
                _antechamber_error(out, err, work_dir)

            charges = _read_amber_charges("temp_out.mol2")

            assert len(charges) == mol.numAtoms

            if abs(sum(charges) - net_charge) > charge_tol:
                raise MetaError(
                    "The difference between the total molecular charge calculated "
                    "via antechamber and the desired net charge is larger than the "
                    "acceptable tolerance."
                    )

            charge_modify = abs(sum(charges) - net_charge) / len(charges)
            charges = [charge + charge_modify for charge in charges]

    #charge_dict = dict()
    for idx, atom in enumerate(mol.atoms):
        atom.charge = charges[idx]
        #charge_dict[atom.type] = atom.charge
    return mol, charges
    
def _antechamber_error(out, err, workdir):
    """Log antechamber output to file. """
    with open(workdir + "/antechamber_log.txt", "w") as log_file:
        log_file.write("STDOUT:\n\n")
        log_file.write(out)
        log_file.write("STDERR:\n\n")
        log_file.write(err)
    raise RuntimeError("Antechamber failed. See 'antechamber_log.txt'")
    
def _read_amber_charges(filepath):
    """Read atomic charges from the temp_out.mol2 file generated by antechamber"""
    charges = []
    start = False
    with open(filepath, "r") as f:
        for line in f.readlines():
            if "ATOM" in line:
                start = True
            elif "BOND" in line:
                start = False
                break
            elif start:
                charges.append(float(line.split()[-1]))

    return charges